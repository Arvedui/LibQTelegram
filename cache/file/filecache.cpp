#include "filecache.h"
#include "../../autogenerated/telegramapi.h"
#include "../../types/telegramhelper.h"
#include "../../crypto/hash.h"
#include "../telegramcache.h"
#include <QStandardPaths>
#include <QDir>

#define CACHE_FOLDER "cache"
#define DOWNLOADS_FOLDER "Telegram"

#define LocalFileId(localfileid) QString::number(localfileid)

FileCache* FileCache::_instance = NULL;

FileCache::FileCache(QObject *parent) : QObject(parent), _currentobject(NULL)
{
    this->_cachepath = QStandardPaths::writableLocation(QStandardPaths::CacheLocation) + QDir::separator() + CACHE_FOLDER;
    this->_downloadspath = QStandardPaths::writableLocation(QStandardPaths::DownloadLocation) + QDir::separator() + DOWNLOADS_FOLDER;

    QDir dir;
    dir.mkpath(this->_cachepath);
    dir.mkpath(this->_downloadspath);
}

FileCache *FileCache::instance()
{
    if(!FileCache::_instance)
        FileCache::_instance = new FileCache();

    return FileCache::_instance;
}

FileObject *FileCache::fileObject(TelegramObject *tgobj)
{
    return this->fileObject(tgobj, false);
}

FileObject *FileCache::upload(FileUploader::MediaType mediatype, const QString &filepath, const QString &caption)
{
    FileObject* fileobject = new FileObject(mediatype, filepath, caption, this->_cachepath, this);
    connect(fileobject, &FileObject::uploadCompleted, this, &FileCache::processQueue);

    this->_filemap[LocalFileId(fileobject->uploader()->localFileId())] = fileobject;

    this->enqueue(fileobject);
    return fileobject;
}

void FileCache::removeObject(TelegramObject *tgobj)
{
    FileObject* fileobject = this->fileObject(tgobj);

    if(!fileobject)
        return;

    this->dequeue(fileobject);
}

void FileCache::saveToDownloads(FileObject *fileobject)
{
    if(!fileobject || !fileobject->downloaded())
        return;

    QString destfolder;
    QMimeType mime = this->_mimedb.mimeTypeForFile(fileobject->filePath());

    if(mime.name().startsWith("image"))
        destfolder = "Image";
    else if(mime.name().startsWith("video"))
        destfolder = "Video";
    else if(mime.name().startsWith("audio"))
        destfolder = "Music";
    else
        destfolder = "Other";

    QDir destpath(this->_downloadspath);
    destpath.mkpath(destpath.absoluteFilePath(destfolder));
    destpath.cd(destfolder);

    if(fileobject->fileName().isEmpty())
    {
        QString filename = QString("%1_%2.%3").arg(destfolder).arg(CurrentTimeStamp).arg(mime.preferredSuffix()).toLower();
        QFile::copy(QDir(this->_cachepath).absoluteFilePath(fileobject->fileId()), destpath.absoluteFilePath(filename));
    }
    else
        QFile::copy(QDir(this->_cachepath).absoluteFilePath(fileobject->fileId()), destpath.absoluteFilePath(fileobject->fileName()));
}

bool FileCache::isMovable(TelegramObject *tgobj) const
{
    if(tgobj->constructorId() != TLTypes::Document)
        return false;

    Document* document = qobject_cast<Document*>(tgobj);
    return !TelegramHelper::isAnimated(document) && !TelegramHelper::isSticker(document) && !TelegramHelper::isAudio(document);
}

QString FileCache::createFileId(TelegramObject *locationobj) const
{
    QByteArray data;

    if(locationobj->constructorId() == TLTypes::Document)
    {
        TLLong id = qobject_cast<Document*>(locationobj)->id();
        data.append(reinterpret_cast<const char*>(&id), sizeof(TLLong));
    }
    else
        locationobj->serialize(data);

    return md5_hash_hex(data);
}

FileObject *FileCache::localFileObject(TelegramObject *tgobj)
{
    if(!tgobj)
        return NULL;

    if(tgobj->constructorId() == TLTypes::PhotoEmpty)
    {
        Photo* photo = qobject_cast<Photo*>(tgobj);

        if(this->_filemap.contains(LocalFileId(photo->id())))
            return this->_filemap[LocalFileId(photo->id())];

    }
    else if(tgobj->constructorId() == TLTypes::Document)
    {
        Document* document = qobject_cast<Document*>(tgobj);

        if(TelegramHelper::isSticker(document))
            return this->fileObject(document);

        if(this->_filemap.contains(LocalFileId(document->id())))
            return this->_filemap[LocalFileId(document->id())];
    }
    if(tgobj->constructorId() == TLTypes::Message)
        return this->localFileObject(qobject_cast<Message*>(tgobj)->media());
    else if(tgobj->constructorId() == TLTypes::MessageMediaPhoto)
        return this->localFileObject(qobject_cast<MessageMedia*>(tgobj)->photo());
    else if(tgobj->constructorId() == TLTypes::MessageMediaDocument)
        return this->localFileObject(qobject_cast<MessageMedia*>(tgobj)->document());

    return NULL;
}

FileObject *FileCache::fileObject(TelegramObject *tgobj, bool autodownload)
{
    if(!tgobj)
        return NULL;

    if(tgobj->constructorId() == TLTypes::Dialog)
    {
        Dialog* dialog = qobject_cast<Dialog*>(tgobj);
        TLInt id = TelegramHelper::identifier(dialog);

        if(TelegramHelper::isChat(dialog) || TelegramHelper::isChannel(dialog))
            return this->fileObject(TelegramCache_chat(id), autodownload);

        return this->fileObject(TelegramCache_user(id), autodownload);
    }
    else if(tgobj->constructorId() == TLTypes::Photo)
    {
        Photo* photo = qobject_cast<Photo*>(tgobj);
        PhotoSize* smallphoto = TelegramHelper::photoSmall(photo);
        PhotoSize* bigphoto = TelegramHelper::photoBig(photo);
        FileObject* fileobj = this->fileObject(bigphoto->location(), smallphoto->location(), autodownload);

        fileobj->setImageSize(QSize(bigphoto->w(), bigphoto->h()));
        return fileobj;
    }
    else if(tgobj->constructorId() == TLTypes::ChatPhoto)
    {
        ChatPhoto* chatphoto = qobject_cast<ChatPhoto*>(tgobj);
        return this->fileObject(chatphoto->photoBig(), chatphoto->photoSmall(), autodownload);
    }
    else if(tgobj->constructorId() == TLTypes::UserProfilePhoto)
    {
        UserProfilePhoto* userprofilephoto = qobject_cast<UserProfilePhoto*>(tgobj);
        return this->fileObject(userprofilephoto->photoBig(), userprofilephoto->photoSmall(), autodownload);
    }
    else if(tgobj->constructorId() == TLTypes::Document)
    {
        Document* document = qobject_cast<Document*>(tgobj);
        return this->fileObject(document, document->thumb()->location(), autodownload);
    }
    else if(tgobj->constructorId() == TLTypes::WebPage)
    {
        WebPage* webpage = qobject_cast<WebPage*>(tgobj);

        if(webpage->photo())
            return this->fileObject(webpage->photo(), TelegramConfig_autoDownload);
    }
    else if(tgobj->constructorId() == TLTypes::Message)
    {
        Message* message = qobject_cast<Message*>(tgobj);

        if(is_local_messageid(message->id()))
            return this->localFileObject(message);

        return this->fileObject(qobject_cast<Message*>(tgobj)->media(), autodownload);
    }
    else if((tgobj->constructorId() == TLTypes::Chat) || (tgobj->constructorId() == TLTypes::Channel))
        return this->fileObject(qobject_cast<Chat*>(tgobj)->photo(), autodownload);
    else if((tgobj->constructorId() == TLTypes::User))
        return this->fileObject(qobject_cast<User*>(tgobj)->photo(), autodownload);
    else if(tgobj->constructorId() == TLTypes::MessageMediaPhoto)
        return this->fileObject(qobject_cast<MessageMedia*>(tgobj)->photo(), TelegramConfig_autoDownload);
    else if(tgobj->constructorId() == TLTypes::MessageMediaDocument)
        return this->fileObject(qobject_cast<MessageMedia*>(tgobj)->document(), autodownload);
    else if(tgobj->constructorId() == TLTypes::MessageMediaWebPage)
        return this->fileObject(qobject_cast<MessageMedia*>(tgobj)->webpage(), true);
    else if(tgobj->constructorId() == TLTypes::FileLocation) // Direct access for debugging purpose
        return this->fileObject(qobject_cast<FileLocation*>(tgobj), qobject_cast<FileLocation*>(tgobj), autodownload);

    return NULL;
}

FileObject *FileCache::fileObject(TelegramObject* locationobj, FileLocation* locthumbnail, bool autodownload)
{
    Q_ASSERT((locationobj->constructorId() == TLTypes::FileLocation) ||
             (locationobj->constructorId() == TLTypes::FileLocationUnavailable) ||
             (locationobj->constructorId() == TLTypes::Document));

    QString fileid = this->createFileId(locationobj);

    if(this->_filemap.contains(fileid))
        return this->_filemap[fileid];

    FileObject* fileobject = new FileObject(this->_cachepath, this);
    fileobject->setAutoDownload(autodownload);
    connect(fileobject, &FileObject::downloadCompleted, this, &FileCache::processQueue);

    if(this->isMovable(locationobj))
        connect(fileobject, SIGNAL(downloadCompleted()), this, SLOT(saveToDownloads()));

    if(locationobj->constructorId() == TLTypes::Document)
    {
        Document* document = qobject_cast<Document*>(locationobj);
        fileobject->setFileId(fileid);
        fileobject->setDocument(document);
    }
    else
    {
        FileLocation* filelocation = qobject_cast<FileLocation*>(locationobj);
        fileobject->setFileId(fileid);
        fileobject->setFileLocation(filelocation);
    }

    if(locthumbnail)
    {
        fileobject->setThumbnailId(this->createFileId(locthumbnail));
        fileobject->setThumbnailLocation(locthumbnail);
    }

    this->_filemap[fileid] = fileobject;

    if(fileobject->loadCache())
        return fileobject;

    this->enqueue(fileobject);
    return fileobject;
}

void FileCache::enqueue(FileObject *fileobject)
{
    this->_queue << fileobject;

    if(!this->_currentobject)
        this->processQueue();
}

void FileCache::dequeue(FileObject *fileobject)
{
    if(!this->_filemap.contains(fileobject->fileId()))
        return;

    int idx = this->_queue.indexOf(fileobject);

    if(idx == -1)
        return;

    this->_queue.removeAt(idx);
    fileobject->deleteLater();
}

void FileCache::processQueue()
{
    if(this->_queue.isEmpty())
    {
        this->_currentobject = NULL;
        return;
    }

    this->_currentobject = this->_queue.takeFirst();

    if(this->_currentobject->isUpload())
        this->_currentobject->upload();
    else
        this->_currentobject->downloadThumbnail();
}

void FileCache::saveToDownloads()
{
    FileObject* fileobject = qobject_cast<FileObject*>(this->sender());
    this->saveToDownloads(fileobject);
}
