#include "filecache.h"
#include "../../autogenerated/telegramapi.h"
#include "../../types/telegramhelper.h"
#include "telegramcache.h"
#include <QCryptographicHash>
#include <QStandardPaths>
#include <QDir>

#define CACHE_FOLDER "cache"

FileCache* FileCache::_instance = NULL;

FileCache::FileCache(QObject *parent) : QObject(parent), _currentobject(NULL)
{
    this->_storagepath = QStandardPaths::writableLocation(QStandardPaths::CacheLocation) + QDir::separator() + CACHE_FOLDER;

    QDir dir;
    dir.mkpath(this->_storagepath);
}

FileCache *FileCache::instance()
{
    if(!FileCache::_instance)
        FileCache::_instance = new FileCache();

    return FileCache::_instance;
}

FileObject *FileCache::fileObject(TelegramObject *tgobj)
{
    if(!tgobj)
        return NULL;

    if(tgobj->constructorId() == TLTypes::Dialog)
    {
        Dialog* dialog = qobject_cast<Dialog*>(tgobj);
        TLInt id = TelegramHelper::identifier(dialog);

        if(TelegramHelper::isChat(dialog) || TelegramHelper::isChannel(dialog))
            return this->fileObject(TelegramCache_chat(id));

        return this->fileObject(TelegramCache_user(id));
    }
    else if(tgobj->constructorId() == TLTypes::Photo)
    {
        Photo* photo = qobject_cast<Photo*>(tgobj);
        PhotoSize* thumbnailphoto = photo->sizes().first();
        PhotoSize* fullphoto = photo->sizes().last();
        FileObject* fileobj = this->fileObject(thumbnailphoto->location(), fullphoto->location());

        fileobj->setImageSize(QSize(fullphoto->w(), fullphoto->h()));
        return fileobj;
    }
    else if(tgobj->constructorId() == TLTypes::ChatPhoto)
    {
        ChatPhoto* chatphoto = qobject_cast<ChatPhoto*>(tgobj);
        return this->fileObject(chatphoto->photoSmall(), chatphoto->photoBig());
    }
    else if(tgobj->constructorId() == TLTypes::UserProfilePhoto)
    {
        UserProfilePhoto* userprofilephoto = qobject_cast<UserProfilePhoto*>(tgobj);
        return this->fileObject(userprofilephoto->photoSmall(), userprofilephoto->photoBig());
    }
    else if(tgobj->constructorId() == TLTypes::Document)
        return this->fileObject(qobject_cast<Document*>(tgobj));
    else if((tgobj->constructorId() == TLTypes::Chat) || (tgobj->constructorId() == TLTypes::Channel))
        return this->fileObject(qobject_cast<Chat*>(tgobj)->photo());
    else if((tgobj->constructorId() == TLTypes::User))
        return this->fileObject(qobject_cast<User*>(tgobj)->photo());
    else if(tgobj->constructorId() == TLTypes::Message)
        return this->fileObject(qobject_cast<Message*>(tgobj)->media());
    else if(tgobj->constructorId() == TLTypes::MessageMediaPhoto)
        return this->fileObject(qobject_cast<MessageMedia*>(tgobj)->photo());
    else if(tgobj->constructorId() == TLTypes::MessageMediaDocument)
        return this->fileObject(qobject_cast<MessageMedia*>(tgobj)->document());

    return NULL;
}

QString FileCache::createFileId(FileLocation *filelocation)
{
    QByteArray indata, outdata;
    TLLong id = filelocation->localId();

    indata.append(reinterpret_cast<const char*>(&id), sizeof(TLLong));
    outdata = QCryptographicHash::hash(indata, QCryptographicHash::Md5);
    return outdata.toHex();
}

QString FileCache::createFileId(Document *document)
{
    QByteArray indata, outdata;
    TLLong id = document->id();

    indata.append(reinterpret_cast<const char*>(&id), sizeof(TLLong));
    outdata = QCryptographicHash::hash(indata, QCryptographicHash::Md5);
    return outdata.toHex();
}

FileObject *FileCache::fileObject(FileLocation *locthumbnail, FileLocation *locfile)
{
    QString fileid = this->createFileId(locfile);

    if(this->_filemap.contains(fileid))
        return this->_filemap[fileid];

    FileObject* fileobject = new FileObject(this->_storagepath, this);
    connect(fileobject, &FileObject::downloadCompleted, this, &FileCache::processQueue);

    fileobject->setThumbnailLocation(locthumbnail);
    fileobject->setFileLocation(locfile);
    fileobject->setThumbnailId(this->createFileId(locthumbnail));
    fileobject->setFileId(fileid);

    this->_filemap[fileid] = fileobject;

    if(fileobject->loadCache())
        return fileobject;

    this->_queue << fileobject;

    if(!this->_currentobject)
        this->processQueue();

    return fileobject;
}

FileObject *FileCache::fileObject(Document *document)
{
    QString fileid = this->createFileId(document);

    if(this->_filemap.contains(fileid))
        return this->_filemap[fileid];

    FileObject* fileobject = new FileObject(this->_storagepath, this);
    connect(fileobject, &FileObject::downloadCompleted, this, &FileCache::processQueue);

    if(document->thumb())
        fileobject->setThumbnailId(this->createFileId(document->thumb()->location()));

    fileobject->setDocument(document);
    fileobject->setFileId(fileid);

    this->_filemap[fileid] = fileobject;

    if(fileobject->loadCache())
        return fileobject;

    this->_queue << fileobject;

    if(!this->_currentobject)
        this->processQueue();

    return fileobject;
}

void FileCache::processQueue()
{
    if(this->_queue.isEmpty())
    {
        this->_currentobject = NULL;
        return;
    }

    this->_currentobject = this->_queue.takeFirst();
    this->_currentobject->downloadThumbnail();
}
