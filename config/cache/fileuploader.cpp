#include "fileuploader.h"
#include "../../autogenerated/telegramapi.h"
#include "../../crypto/hash.h"
#include "../../crypto/math.h"
#include <QFile>
#include <QUrl>

#define BlockSize    (32 * 1024)
#define TenMegaBytes (10 * 1024 * 1024)

QMimeDatabase FileUploader::_mimedb;

FileUploader::FileUploader(MediaType mediatype, QObject *parent) : QObject(parent), _dcsession(NULL), _isbigfile(false), _partsize(BlockSize), _partscount(0), _partnum(0)
{
    this->_mediatype = mediatype;
    this->_localfileid = Math::randomize<TLLong>();
}

FileUploader::~FileUploader()
{
    if(this->_dcsession)
    {
        DC_CloseSession(this->_dcsession);
        this->_dcsession = NULL;
    }

    if(this->_file.isOpen())
        this->_file.close();
}

FileUploader::MediaType FileUploader::mediaType() const
{
    return this->_mediatype;
}

TLLong FileUploader::localFileId() const
{
    return this->_localfileid;
}

QString FileUploader::caption() const
{
    return this->_caption;
}

QString FileUploader::fileName() const
{
    return this->_filename;
}

QString FileUploader::md5hash() const
{
    return this->_md5hash;
}

QString FileUploader::mimeType() const
{
    return this->_mimetype;
}

TLInt FileUploader::partsCount() const
{
    return this->_partscount;
}

qreal FileUploader::progress() const
{
    return this->_partnum / static_cast<qreal>(this->_partscount);
}

bool FileUploader::uploading() const
{
    return (this->_partnum) > 0 && (this->_partnum < this->_partscount);
}

bool FileUploader::isBigFile() const
{
    return this->_isbigfile;
}

void FileUploader::setCaption(const QString &caption)
{
    this->_caption = caption;
}

void FileUploader::upload(const QString &filepath)
{
    QFileInfo fileinfo(filepath);

    if(!this->calculatePartsLength(&fileinfo))
        return;

    this->calculatePartsCount(&fileinfo);

    this->_isbigfile = (fileinfo.size() > TenMegaBytes);
    this->_filename = fileinfo.fileName();
    this->_mimetype = FileUploader::_mimedb.mimeTypeForFile(filepath).name();
    this->_file.setFileName(filepath);

    if(!this->_file.open(QFile::ReadWrite))
    {
        qWarning("UPLOAD Cannot open %s", qUtf8Printable(filepath));
        emit failed();
        return;
    }

    if(!this->_isbigfile)
    {
        this->_md5hash = md5_hash_hex(this->_file.readAll());
        this->_file.reset();
    }

    this->_dcsession = DC_CreateFileSession(DCConfig_mainConfig);
    connect(this->_dcsession, &DCSession::ready, this, &FileUploader::uploadPart);
    DC_InitializeSession(this->_dcsession);
}

bool FileUploader::calculatePartsLength(const QFileInfo *fileinfo)
{
    TLInt val = (fileinfo->size() + 2999) / 3000;

    while(this->_partsize < val)
        this->_partsize *= 2;

    if(this->_partsize > (512 << 10))
    {
        qWarning("UPLOAD File too big");
        emit failed();
        return false;
    }

    return true;
}

void FileUploader::calculatePartsCount(const QFileInfo* fileinfo)
{
    this->_partscount = fileinfo->size() / this->_partsize;

    if((this->_partscount * this->_partsize) < fileinfo->size())
        this->_partscount++;
}

void FileUploader::getNextPart(TLBytes &data)
{
    this->_file.seek(this->_partnum * this->_partsize);
    data = this->_file.read(this->_partsize);
}

void FileUploader::uploadPart()
{
    TLBytes partdata;
    this->getNextPart(partdata);

    MTProtoRequest* req = NULL;

    if(!this->_isbigfile)
        req = TelegramAPI::uploadSaveFilePart(this->_dcsession, this->_localfileid, this->_partnum, partdata);
    else
        req = TelegramAPI::uploadSaveBigFilePart(this->_dcsession, this->_localfileid, this->_partnum, this->_partscount, partdata);

    connect(req, &MTProtoRequest::replied, this, &FileUploader::onSaveFilePartReplied);
    emit uploadingChanged();
}

void FileUploader::onSaveFilePartReplied(MTProtoReply *mtreply)
{
    TLConstructor result = mtreply->readTLConstructor();

    if(result == TLTypes::BoolFalse)
    {
        qWarning("UPLOAD File transfer failed (part: %d/%d)", this->_partnum, this->_partscount);
        emit failed();
        return;
    }

    this->_partnum++;
    emit progressChanged();

    if(this->_partnum >= this->_partscount)
    {
        emit uploadingChanged();
        emit completed();
        return;
    }

    this->uploadPart();
}
