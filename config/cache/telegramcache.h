#ifndef TELEGRAMCACHE_H
#define TELEGRAMCACHE_H

#define TelegramCache_instance TelegramCache::cache()
#define TelegramCache_save TelegramCache::cache()->save();
#define TelegramCache_load TelegramCache::cache()->load();
#define TelegramCache_store(objs) TelegramCache::cache()->cache(objs);

#define TelegramCache_dialogs TelegramCache::cache()->dialogs()
#define TelegramCache_users TelegramCache::cache()->users()
#define TelegramCache_chats TelegramCache::cache()->chats()
#define TelegramCache_messages TelegramCache::cache()->messages()

#define TelegramCache_dialog(dialogid) TelegramCache::cache()->dialog(dialogid)
#define TelegramCache_user(userid) TelegramCache::cache()->user(userid)
#define TelegramCache_chat(chatid) TelegramCache::cache()->chat(chatid)
#define TelegramCache_message(messageid) TelegramCache::cache()->message(messageid)

#include <QObject>
#include <QDir>
#include "../../autogenerated/types/types.h"
#include "../../mtproto/mtprotoreply.h"
#include "../../types/telegramhelper.h"
#include "../telegramconfig.h"

class TelegramCache: public QObject
{
    Q_OBJECT

    private:
        TelegramCache(QObject *parent = NULL);
        template<typename T> void loadFromFile(QHash<TLInt, T *> &container, const QString& name);
        template<typename T> void saveToFile(const QHash<TLInt, T*>& container, const QString& name) const;
        template<typename T> void cache(const TLVector<T*>& src, QHash<TLInt, T*>& dest);
        template<typename T> void cache(T* src, QHash<TLInt, T*>& dest);

    public:
        static TelegramCache* cache();
        void save() const;
        void load();
        const QHash<TLInt, Dialog *> &dialogs() const;
        const QHash<TLInt, User*>& users() const;
        const QHash<TLInt, Chat*>& chats() const;
        const QHash<TLInt, Message*>& messages() const;
        Dialog* dialog(TLInt id) const;
        User* user(TLInt id) const;
        Chat* chat(TLInt id) const;
        Message* message(TLInt id) const;

    public slots:
        void cache(Dialog* dialog);
        void cache(User* user);
        void cache(Chat* chat);
        void cache(Message* message);
        void cache(const TLVector<Dialog *> &dialogs);
        void cache(const TLVector<User *> &users);
        void cache(const TLVector<Chat *> &chats);
        void cache(const TLVector<Message *> &messages);

    private slots:
        void onNewMessage(Message* message);
        void onEditMessage(Message* message);
        void onNewUserStatus(Update* update);
        void onNewDraftMessage(Update* update);

    signals:
        void dialogsChanged();

    private:
        QHash<TLInt, Dialog*> _dialogs;
        QHash<TLInt, User*> _users;
        QHash<TLInt, Chat*> _chats;
        QHash<TLInt, Message*> _messages;

    private:
        static TelegramCache* _instance;
};

template<typename T> void TelegramCache::cache(T *t, QHash<TLInt, T*> &dest)
{
    TLInt id = TelegramHelper::identifier(t);

    if(dest.contains(id))
        return;

    dest[id] = t;
}

template<typename T> void TelegramCache::cache(const TLVector<T*>& src, QHash<TLInt, T*>& dest)
{
    foreach(T* t, src)
        this->cache(t, dest);
}

template<typename T> void TelegramCache::loadFromFile(QHash<TLInt, T*> &container, const QString &name)
{
    QDir dir(TelegramConfig_instance->storagePath());
    dir.mkpath(TelegramConfig_instance->storagePath());

    QFile f(dir.absoluteFilePath(name) + ".cache");

    if(!f.open(QFile::ReadOnly))
        return;

    QByteArray data = f.readAll();
    f.close();

    MTProtoStream mtstream(data);
    TLVector<T*> elements;

    mtstream.readTLVector<T>(elements);

    foreach(T* t, elements)
        container[TelegramHelper::identifier(t)] = t;
}

template<typename T> void TelegramCache::saveToFile(const QHash<TLInt, T*>& container, const QString& name) const
{
    MTProtoStream mtstream;
    mtstream.writeTLVector<T>(container.values());

    QDir dir(TelegramConfig_instance->storagePath());
    dir.mkpath(TelegramConfig_instance->storagePath());

    QFile f(dir.absoluteFilePath(name) + ".cache");

    if(!f.open(QFile::WriteOnly))
    {
        qWarning() << "Cannot save cache file in" << f.fileName();
        return;
    }

    f.write(mtstream.data());
    f.close();
}

#endif // TELEGRAMCACHE_H
