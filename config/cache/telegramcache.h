#ifndef TELEGRAMCACHE_H
#define TELEGRAMCACHE_H

#define TelegramCache_instance TelegramCache::cache()
#define TelegramCache_load TelegramCache::cache()->load();
#define TelegramCache_store(objs) TelegramCache::cache()->cache(objs);

#define TelegramCache_hasDialog(dialogid) TelegramCache::cache()->hasDialog(dialogid)
#define TelegramCache_markAsRead(dialog) TelegramCache::cache()->markAsRead(dialog)

#define TelegramCache_dialogs TelegramCache::cache()->dialogs()
#define TelegramCache_contacts TelegramCache::cache()->contacts()

#define TelegramCache_user(userid) TelegramCache::cache()->user(userid)
#define TelegramCache_chat(chatid) TelegramCache::cache()->chat(chatid)

#define TelegramCache_cacheNotify(message) TelegramCache::cache()->cacheNotify(message)
#define TelegramCache_message(messageid) TelegramCache::cache()->message(messageid)
#define TelegramCache_messages(dialogid, offset, limit) TelegramCache::cache()->dialogMessages(dialogid, offset, limit)

#include <QObject>
#include <QList>
#include <QDir>
#include "../../autogenerated/types/types.h"
#include "../../mtproto/mtprotoreply.h"
#include "../../types/telegramhelper.h"
#include "../telegramconfig.h"
#include "database/cachedatabase.h"
#include "cachefetcher.h"

class TelegramCache: public QObject
{
    Q_OBJECT

    private:
        TelegramCache(QObject *parent = NULL);

    public:
        static TelegramCache* cache();
        void load();
        const QList<Dialog*> &dialogs() const;
        const QList<User*> &contacts() const;
        QList<Message*> dialogMessages(Dialog* dialog, int offset, int limit);
        User* user(TLInt id, bool ignoreerror = false);
        Chat* chat(TLInt id, bool ignoreerror = false);
        Message* message(MessageId messageid, bool ignoreerror = false);
        Dialog* dialog(TLInt id, bool ignoreerror = false) const;
        bool hasDialog(TLInt id) const;
        void markAsRead(Dialog* dialog);

    public slots:
        void cache(Dialog* dialog);
        void cache(User* user);
        void cache(Chat* chat);
        void cache(Message* message);
        void cache(const TLVector<Dialog *> &dialogs);
        void cache(const TLVector<User *> &users);
        void cache(const TLVector<Chat *> &chats);
        void cache(const TLVector<Message *> &messages);
        void cacheNotify(Message* message);
        void cacheNotify(const TLVector<Dialog *> &dialogs);

    private slots:
        void onNewUserStatus(Update* update);
        void onNewDraftMessage(Update* update);
        void onEditMessage(Message* message);
        void onNewMessages(const TLVector<Message*>& messages);
        void onDeleteMessages(const TLVector<TLInt>& messageids);
        void onReadHistory(Update* update);
        void onTyping(Update* update);

    signals:
        void dialogsChanged();
        void newDialogs(const TLVector<Dialog *> &dialogs);
        void newMessage(Message* message);
        void editMessage(Message* message);
        void deleteMessage(Message* message);
        void readInbox(Dialog* dialog);
        void typing(Dialog* dialog, SendMessageAction* sendmessageaction);

    private:
        QList<Dialog*> _dialogs;
        QList<User*> _contacts;
        QHash<TLInt, Chat*> _chats;
        QHash<TLInt, User*> _users;
        QHash<MessageId, Message*> _messages;
        CacheDatabase* _database;
        CacheFetcher* _fetcher;

    private:
        static TelegramCache* _instance;
};

#endif // TELEGRAMCACHE_H
