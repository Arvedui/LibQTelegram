#ifndef TELEGRAMCACHE_H
#define TELEGRAMCACHE_H

#define TelegramCache_instance TelegramCache::cache()
#define TelegramCache_load TelegramCache::cache()->load();
#define TelegramCache_store(objs) TelegramCache::cache()->cache(objs);

#define TelegramCache_dialogs TelegramCache::cache()->dialogs()
#define TelegramCache_contacts TelegramCache::cache()->contacts()
#define TelegramCache_messages(dialogid, limit) TelegramCache::cache()->dialogMessages(dialogid, limit)

#define TelegramCache_user(userid) TelegramCache::cache()->user(userid)
#define TelegramCache_chat(chatid) TelegramCache::cache()->chat(chatid)
#define TelegramCache_message(messageid) TelegramCache::cache()->message(messageid)

#include <QObject>
#include <QList>
#include <QDir>
#include "../../autogenerated/types/types.h"
#include "../../mtproto/mtprotoreply.h"
#include "../../types/telegramhelper.h"
#include "../telegramconfig.h"
#include "database/cachedatabase.h"

class TelegramCache: public QObject
{
    Q_OBJECT

    private:
        TelegramCache(QObject *parent = NULL);
        template<typename T> void loadFromFile(QHash<TLInt, T *> &container, const QString& name);
        template<typename T> void saveToFile(const QHash<TLInt, T*>& container, const QString& name) const;
        template<typename T> void cache(const TLVector<T*>& src, QHash<TLInt, T*>& dest);
        template<typename T> void cache(T* t, QHash<TLInt, T*>& dest);

    public:
        static TelegramCache* cache();
        void load();
        const QList<Dialog*> &dialogs() const;
        const QList<User*> &contacts() const;
        QList<Message*> dialogMessages(Dialog* dialog, int limit);
        User* user(TLInt id);
        Chat* chat(TLInt id);
        Message* message(TLInt id);
        Dialog* dialog(TLInt id);

    public slots:
        void cache(Dialog* dialog);
        void cache(User* user);
        void cache(Chat* chat);
        void cache(Message* message);
        void cache(const TLVector<Dialog *> &dialogs);
        void cache(const TLVector<User *> &users);
        void cache(const TLVector<Chat *> &chats);
        void cache(const TLVector<Message *> &messages);

    private slots:
        void onNewMessages(const TLVector<Message*>& messages);
        void onNewMessage(Message* message);
        void onNewUserStatus(Update* update);
        void onNewDraftMessage(Update* update);
        void onEditMessage(Message* message);
        void onDeleteMessages(const TLVector<TLInt>& messageids);
        void onReadHistory(Update* update);

    signals:
        void dialogsChanged();
        void newMessage(Message* message);
        void deleteMessage(Message* message);

    private:
        QList<Dialog*> _dialogs;
        QList<User*> _contacts;
        QHash<TLInt, Chat*> _chats;
        QHash<TLInt, User*> _users;
        QHash<TLInt, Message*> _messages;
        CacheDatabase* _database;

    private:
        static TelegramCache* _instance;
};

template<typename T> void TelegramCache::cache(T *t, QHash<TLInt, T*> &dest)
{
    TLInt id = TelegramHelper::identifier(t);

    if(dest.contains(id))
        return;

    t->setParent(this);
    dest[id] = t;
}

template<typename T> void TelegramCache::cache(const TLVector<T*>& src, QHash<TLInt, T*>& dest)
{
    foreach(T* t, src)
        this->cache(t, dest);
}

template<typename T> void TelegramCache::loadFromFile(QHash<TLInt, T*> &container, const QString &name)
{
    QDir dir(TelegramConfig_storagePath);
    dir.mkpath(TelegramConfig_storagePath);

    MTProtoStream mtstream;
    mtstream.load(dir.absoluteFilePath(name) + ".cache");

    TLVector<T*> elements;
    mtstream.readTLVector<T>(elements, false, this);

    foreach(T* t, elements)
        container[TelegramHelper::identifier(t)] = t;
}

template<typename T> void TelegramCache::saveToFile(const QHash<TLInt, T*>& container, const QString& name) const
{
    QDir dir(TelegramConfig_storagePath);
    dir.mkpath(TelegramConfig_storagePath);

    MTProtoStream mtstream;
    mtstream.writeTLVector<T>(container.values());
    mtstream.save(dir.absoluteFilePath(name) + ".cache");
}

#endif // TELEGRAMCACHE_H
