#include "mtprotoservicehandler.h"
#include "../autogenerated/mtproto/mtproto.h"
#include "../crypto/gzip.h"
#include "../config/telegramconfig.h"
#include <QRegularExpression>

MTProtoServiceHandler::MTProtoServiceHandler(int dcid, QObject *parent) : QObject(parent), _dcid(dcid)
{

}

bool MTProtoServiceHandler::handle(MTProtoReply *mtreply)
{
    if(mtreply->constructorId() == TLTypes::MsgContainer)
        return this->handleMsgContainer(mtreply);

    if(mtreply->constructorId() == TLTypes::RpcResult)
        return this->handleRpcResult(mtreply);

    if(mtreply->constructorId() == TLTypes::RpcError)
        return this->handleRpcError(mtreply);

    if((mtreply->constructorId() == TLTypes::BadMsgNotification) || (mtreply->constructorId() == TLTypes::BadServerSalt))
        return this->handleBadMsgNotification(mtreply);

    if(mtreply->constructorId() == TLTypes::GzipPacked)
        return this->handleGzipPacked(mtreply);

    if(mtreply->constructorId() == TLTypes::NewSessionCreated)
        return this->handleNewSessionCreated(mtreply);

    if(mtreply->constructorId() == TLTypes::MsgsAck)
        return this->handleMsgAck(mtreply);

    return false;
}

bool MTProtoServiceHandler::handleMsgContainer(MTProtoReply *mtreply)
{
    MessageContainer mc;
    mc.read(mtreply);

    foreach(MTProtoMessage* message, mc.messages())
    {
        MTProtoReply mtreplymsg(message, this->_dcid);
        emit serviceHandled(&mtreplymsg);
    }

    return true;
}

bool MTProtoServiceHandler::handleRpcResult(MTProtoReply *mtreply)
{
    RpcResult rr;
    rr.read(mtreply);

    MTProtoReply mtreplymsg(rr.result(), rr.reqMsgId(), this->_dcid);
    emit serviceHandled(&mtreplymsg);

    return true;
}

bool MTProtoServiceHandler::handleRpcError(MTProtoReply *mtreply)
{
    RpcError re;
    re.read(mtreply);

    if(re.errorMessage().contains("_MIGRATE_"))
    {
        QRegularExpression regexp("_MIGRATE_([0-9]+)");
        QRegularExpressionMatch match = regexp.match(re.errorMessage());
        QString dcnum = match.captured(1);

        if(dcnum.isNull())
        {
            qFatal("DC %d Unknown destination DC: %s", this->_dcid, qUtf8Printable(dcnum));
            return true;
        }

        emit migrateDC(this->_dcid, dcnum.toInt());
    }
    else if(re.errorMessage().contains("AUTH_KEY_"))
    {
        qDebug("DC %d Unauthorized client, requesting new authorization...", this->_dcid);
        emit unauthorized();
    }
    else if(re.errorMessage().contains("FLOOD_WAIT_"))
    {
        QRegularExpression regexp("FLOOD_WAIT_([0-9]+)");
        QRegularExpressionMatch match = regexp.match(re.errorMessage());
        QString seconds = match.captured(1);

        if(!seconds.isNull())
        {
            qWarning("DC %d Flood lock enabled (%s seconds)", this->_dcid, qUtf8Printable(seconds));
            emit floodWait(seconds.toInt());
        }
        else
            qFatal("DC %d Cannot get flood duration", this->_dcid);
    }
    else
        qWarning("DC %d (%llx) RPC Error %d %s", this->_dcid, mtreply->messageId(), re.errorCode(), qUtf8Printable(re.errorMessage()));

    return true;
}

bool MTProtoServiceHandler::handleBadMsgNotification(MTProtoReply *mtreply)
{
    BadMsgNotification badmsgnotification;
    badmsgnotification.read(mtreply);

    if(badmsgnotification.constructorId() == BadMsgNotification::CtorBadMsgNotification)
    {
        if(badmsgnotification.errorCode() == 16)
            qWarning() << "BadMsgNotification: msg_id too low";
        else if(badmsgnotification.errorCode() == 17)
            qWarning() << "BadMsgNotification: msg_id too high";
        else if(badmsgnotification.errorCode() == 18)
            qWarning() << "BadMsgNotification: Incorrect two lower order msg_id bits";
        else if(badmsgnotification.errorCode() == 19)
            qWarning() << "BadMsgNotification: Container msg_id is the same as msg_id of a previously received message";
        else if(badmsgnotification.errorCode() == 20)
            qWarning() << "BadMsgNotification: Message too old";
        else if(badmsgnotification.errorCode() == 32)
            qWarning() << "BadMsgNotification: msg_seqno too low";
        else if(badmsgnotification.errorCode() == 33)
            qWarning() << "BadMsgNotification: msg_seqno too high";
        else if(badmsgnotification.errorCode() == 34)
            qWarning() << "BadMsgNotification: Even msg_seqno expected";
        else if(badmsgnotification.errorCode() == 35)
            qWarning() << "BadMsgNotification: Odd msg_seqno expected";
        else if(badmsgnotification.errorCode() == 48)
            qWarning() << "BadMsgNotification: Incorrect Server Salt";
        else if(badmsgnotification.errorCode() == 64)
            qWarning() << "BadMsgNotification: Invalid container";
        else
            qWarning("BadMsgNotification: unknown error code %d", badmsgnotification.errorCode());
    }
    else if(badmsgnotification.constructorId() == BadMsgNotification::CtorBadServerSalt)
    {
        qDebug("DC %d New salt %llx", this->_dcid, badmsgnotification.newServerSalt());
        DCConfig& config = DCConfig_fromDcId(this->_dcid);
        config.setServerSalt(badmsgnotification.newServerSalt());
        TelegramConfig_save;

        emit saltChanged(badmsgnotification.badMsgId());
    }

    return true;
}

bool MTProtoServiceHandler::handleGzipPacked(MTProtoReply *mtreply)
{
    MTProtoObject mtobj;
    mtobj.read(mtreply);

    TLBytes packeddata = mtobj.packedData();
    TLBytes unpackeddata = GZip::uncompress(packeddata);
    MTProtoReply mtreplymsg(unpackeddata, mtreply->messageId(), this->_dcid);
    emit serviceHandled(&mtreplymsg);

    return true;
}

bool MTProtoServiceHandler::handleNewSessionCreated(MTProtoReply *mtreply)
{
    Q_UNUSED(mtreply);
    NewSession newsession;
    newsession.read(mtreply);

    qDebug("DC %d New Session (first messageid: %llx)", this->_dcid, newsession.firstMsgId());
    return true;
}

bool MTProtoServiceHandler::handleMsgAck(MTProtoReply *mtreply)
{
    Q_UNUSED(mtreply);

    MsgsAck msgsack;
    msgsack.read(mtreply);

    emit ack(msgsack.msgIds());
    return true;
}
