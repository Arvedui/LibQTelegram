#include "mtprotoservicehandler.h"
#include "../autogenerated/mtproto/mtproto.h"
#include "../crypto/gzip.h"
#include "../config/telegramconfig.h"
#include <QRegularExpression>

MTProtoServiceHandler::MTProtoServiceHandler(int dcid, QObject *parent) : QObject(parent), _dcid(dcid)
{

}

bool MTProtoServiceHandler::handle(MTProtoReply *mtreply)
{
    if(mtreply->constructorId() == TLTypes::MsgContainer)
        return this->handleMsgContainer(mtreply);

    if(mtreply->constructorId() == TLTypes::RpcResult)
        return this->handleRpcResult(mtreply);

    if(mtreply->constructorId() == TLTypes::RpcError)
        return this->handleRpcError(mtreply);

    if((mtreply->constructorId() == TLTypes::BadMsgNotification) || (mtreply->constructorId() == TLTypes::BadServerSalt))
        return this->handleBadMsgNotification(mtreply);

    if(mtreply->constructorId() == TLTypes::GzipPacked)
        return this->handleGzipPacked(mtreply);

    if(mtreply->constructorId() == TLTypes::NewSessionCreated)
        return this->handleNewSessionCreated(mtreply);

    if(mtreply->constructorId() == TLTypes::MsgsAck)
        return this->handleMsgAck(mtreply);

    if(mtreply->constructorId() == TLTypes::Config)
        return this->handleConfig(mtreply);

    return false;
}

bool MTProtoServiceHandler::handleMsgContainer(MTProtoReply *mtreply)
{
    MessageContainer mc;
    mc.read(mtreply);

    foreach(MTProtoMessage* message, mc.messages())
    {
        MTProtoReply mtreplymsg(message, this->_dcid);
        emit serviceHandled(&mtreplymsg);
    }

    return true;
}

bool MTProtoServiceHandler::handleRpcResult(MTProtoReply *mtreply)
{
    RpcResult rr;
    rr.read(mtreply);

    MTProtoReply mtreplymsg(rr.result(), rr.reqMsgId(), this->_dcid);
    emit serviceHandled(&mtreplymsg);

    return true;
}

bool MTProtoServiceHandler::handleRpcError(MTProtoReply *mtreply)
{
    RpcError re;
    re.read(mtreply);

    if(re.errorMessage().indexOf("_MIGRATE_") != -1)
    {
        QRegularExpression regexp("_MIGRATE_([0-9]+)");
        QRegularExpressionMatch match = regexp.match(re.errorMessage());
        QStringRef dcnum = match.capturedRef(1);

        if(dcnum.isNull())
        {
            qFatal("Unknown destination DC: %s", dcnum.toUtf8().constData());
            return true;
        }

        emit migrateDC(this->_dcid, dcnum.toInt());
    }

    return true;
}

bool MTProtoServiceHandler::handleBadMsgNotification(MTProtoReply *mtreply)
{
    BadMsgNotification badmsgnotification;
    badmsgnotification.read(mtreply);

    if(badmsgnotification.constructorId() == BadMsgNotification::CtorBadMsgNotification)
    {
        if(badmsgnotification.errorCode() == 16)
            qWarning() << "BadMsgNotification: msg_id too low";
        else if(badmsgnotification.errorCode() == 17)
            qWarning() << "BadMsgNotification: msg_id too high";
        else if(badmsgnotification.errorCode() == 18)
            qWarning() << "BadMsgNotification: Incorrect two lower order msg_id bits";
        else if(badmsgnotification.errorCode() == 19)
            qWarning() << "BadMsgNotification: Container msg_id is the same as msg_id of a previously received message";
        else if(badmsgnotification.errorCode() == 20)
            qWarning() << "BadMsgNotification: Message too old";
        else if(badmsgnotification.errorCode() == 32)
            qWarning() << "BadMsgNotification: msg_seqno too low";
        else if(badmsgnotification.errorCode() == 33)
            qWarning() << "BadMsgNotification: msg_seqno too high";
        else if(badmsgnotification.errorCode() == 34)
            qWarning() << "BadMsgNotification: Even msg_seqno expected";
        else if(badmsgnotification.errorCode() == 35)
            qWarning() << "BadMsgNotification: Odd msg_seqno expected";
        else if(badmsgnotification.errorCode() == 48)
            qWarning() << "BadMsgNotification: Incorrect Server Salt";
        else if(badmsgnotification.errorCode() == 64)
            qWarning() << "BadMsgNotification: Invalid container";
        else
            qWarning("BadMsgNotification: unknown error code %d", badmsgnotification.errorCode());
    }
    else if(badmsgnotification.constructorId() == BadMsgNotification::CtorBadServerSalt)
    {
        DCConfig& config = DCConfig_fromDcId(this->_dcid);
        config.setServerSalt(badmsgnotification.newServerSalt());
        TelegramConfig_save;

        emit saltChanged();
    }

    return true;
}

bool MTProtoServiceHandler::handleGzipPacked(MTProtoReply *mtreply)
{
    MTProtoObject mtobj;
    mtobj.read(mtreply);

    TLBytes packeddata = mtobj.packedData();
    TLBytes unpackeddata = GZip::uncompress(packeddata);
    MTProtoReply mtreplymsg(unpackeddata, mtreply->messageId(), this->_dcid);
    emit serviceHandled(&mtreplymsg);

    return true;
}

bool MTProtoServiceHandler::handleNewSessionCreated(MTProtoReply *mtreply)
{
    Q_UNUSED(mtreply);

    qDebug() << "Unhandled NewSessionCreated";
    return true;
}

bool MTProtoServiceHandler::handleMsgAck(MTProtoReply *mtreply)
{
    Q_UNUSED(mtreply);

    qDebug() << "Unhandled MsgAck";
    return true;
}

bool MTProtoServiceHandler::handleConfig(MTProtoReply *mtreply)
{
    Config config;
    config.read(mtreply);

    emit configurationReceived(&config);
    return true;
}
