#include "mtprotoservicehandler.h"
#include "../autogenerated/mtproto/mtproto.h"
#include "../crypto/gzip.h"
#include "../config/telegramconfig.h"
#include <QRegularExpression>

MTProtoServiceHandler::MTProtoServiceHandler(int dcid, QObject *parent) : QObject(parent), _dcid(dcid)
{

}

bool MTProtoServiceHandler::handle(MTProtoReply *mtreply)
{
    if(mtreply->constructorId() == TLTypes::MsgContainer)
        return this->handleMsgContainer(mtreply);

    if(mtreply->constructorId() == TLTypes::RpcResult)
        return this->handleRpcResult(mtreply);

    if(mtreply->constructorId() == TLTypes::RpcError)
        return this->handleRpcError(mtreply);

    if(mtreply->constructorId() == TLTypes::GzipPacked)
        return this->handleGzipPacked(mtreply);

    if(mtreply->constructorId() == TLTypes::NewSessionCreated)
        return this->handleNewSessionCreated(mtreply);

    if(mtreply->constructorId() == TLTypes::MsgsAck)
        return this->handleMsgAck(mtreply);

    if(mtreply->constructorId() == TLTypes::Config)
        return this->handleConfig(mtreply);

    return false;
}

bool MTProtoServiceHandler::handleMsgContainer(MTProtoReply *mtreply)
{
    MessageContainer mc;
    mc.read(mtreply);

    foreach(MTProtoMessage* message, mc.messages())
    {
        MTProtoReply mtreplymsg(message, this->_dcid);
        emit serviceHandled(&mtreplymsg);
    }

    return true;
}

bool MTProtoServiceHandler::handleRpcResult(MTProtoReply *mtreply)
{
    RpcResult rr;
    rr.read(mtreply);

    MTProtoReply mtreplymsg(rr.result(), rr.reqMsgId(), this->_dcid);
    emit serviceHandled(&mtreplymsg);

    return true;
}

bool MTProtoServiceHandler::handleRpcError(MTProtoReply *mtreply)
{
    RpcError re;
    re.read(mtreply);

    if(re.errorMessage().indexOf("_MIGRATE_") != -1)
    {
        QRegularExpression regexp("_MIGRATE_([0-9]+)");
        QRegularExpressionMatch match = regexp.match(re.errorMessage());
        QStringRef dcnum = match.capturedRef(1);

        if(dcnum.isNull())
        {
            qFatal("Unknown destination DC: %s", dcnum.toUtf8().constData());
            return true;
        }

        emit migrateDC(dcnum.toInt());
    }

    return true;
}

bool MTProtoServiceHandler::handleGzipPacked(MTProtoReply *mtreply)
{
    MTProtoObject mtobj;
    mtobj.read(mtreply);

    TLBytes packeddata = mtobj.packedData();
    TLBytes unpackeddata = GZip::uncompress(packeddata);
    MTProtoReply mtreplymsg(unpackeddata, mtreply->messageId(), this->_dcid);
    emit serviceHandled(&mtreplymsg);

    return true;
}

bool MTProtoServiceHandler::handleNewSessionCreated(MTProtoReply *mtreply)
{
    Q_UNUSED(mtreply);

    qDebug() << "Unhandled NewSessionCreated";
    return true;
}

bool MTProtoServiceHandler::handleMsgAck(MTProtoReply *mtreply)
{
    Q_UNUSED(mtreply);

    qDebug() << "Unhandled MsgAck";
    return true;
}

bool MTProtoServiceHandler::handleConfig(MTProtoReply *mtreply)
{
    Config config;
    config.read(mtreply);

    emit configurationReceived(&config);
    return true;
}
